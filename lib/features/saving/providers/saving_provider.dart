import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../core/network/supabase_client.dart';
import 'package:nerve/features/auth/providers/auth_provider.dart';
import '../domain/saving_model.dart';
import 'package:nerve/features/wishlist/providers/wishlist_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

part 'saving_provider.g.dart';

@Riverpod(keepAlive: true)
class SavingNotifier extends _$SavingNotifier {
  // Local storage for guest users
  final List<SavingModel> _guestSavings = [];

  @override
  FutureOr<List<SavingModel>> build() async {
    final authNotifier = ref.watch(authProvider.notifier);
    final user = ref.watch(authProvider).asData?.value;

    if (authNotifier.isGuest || user == null) {
      // [Persistence] Load from SharedPrefs
      try {
        final prefs = await SharedPreferences.getInstance();
        final String? storedData = prefs.getString('guest_savings');
        if (storedData != null) {
          final List<dynamic> decoded = jsonDecode(storedData);
          _guestSavings.clear();
          _guestSavings.addAll(
            decoded.map((e) => SavingModel.fromJson(e)).toList(),
          );
        }
      } catch (e) {
        debugPrint('Failed to load guest savings: $e');
      }
      return _guestSavings;
    }

    // Fetch from Supabase for logged-in users
    try {
      final response = await ref
          .read(supabaseProvider)
          .from('savings')
          .select()
          .order('created_at', ascending: false);

      // Filter out items with null IDs
      final safeResponse = response.where((e) => e['id'] != null).toList();

      if (safeResponse.length < response.length) {
        debugPrint(
          'Filtered out ${response.length - safeResponse.length} savings with null IDs',
        );
      }
      return safeResponse.map((e) => SavingModel.fromJson(e)).toList();
    } catch (e) {
      // [Resilience] If select('*') fails due to missing 'note' column
      if (e.toString().contains('PGRST204') || e.toString().contains('note')) {
        debugPrint(
          'Fetch failed due to missing note column, falling back to safe select...',
        );
        final fallbackResponse = await ref
            .read(supabaseProvider)
            .from('savings')
            .select('id, category, amount, created_at, wishlist_ids')
            .order('created_at', ascending: false);
        return fallbackResponse.map((e) => SavingModel.fromJson(e)).toList();
      }
      rethrow;
    }
  }

  Future<void> addSaving({
    required String category,
    required dynamic amount,
    required DateTime createdAt,
    String? note,
    List<String> wishlistIds = const [],
  }) async {
    final authNotifier = ref.read(authProvider.notifier);
    final user = ref.read(authProvider).asData?.value;

    // Safe parsing logic
    final int parsedAmount = int.tryParse(amount?.toString() ?? '0') ?? 0;

    if (authNotifier.isGuest || user == null) {
      // Generate a temporary ID for guest
      final newItem = SavingModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        category: category,
        amount: parsedAmount,
        createdAt: createdAt,
        note: note,
        wishlistIds: wishlistIds,
      );
      _guestSavings.insert(0, newItem);

      // [Persistence] Save to SharedPrefs
      try {
        final prefs = await SharedPreferences.getInstance();
        final String encodedData = jsonEncode(
          _guestSavings.map((e) => e.toJson()).toList(),
        );
        await prefs.setString('guest_savings', encodedData);
      } catch (e) {
        debugPrint('Failed to save guest savings: $e');
      }

      state = AsyncValue.data([..._guestSavings]);
      return;
    }

    final newItem = SavingModel(
      id: '', // Empty ID as it will be generated by Supabase (toJson omits it)
      category: category,
      amount: parsedAmount,
      createdAt: createdAt,
      note: note,
      wishlistIds: wishlistIds,
    );

    try {
      final response = await ref
          .read(supabaseProvider)
          .from('savings')
          .insert({...newItem.toJson(), 'user_id': user.id})
          .select()
          .single();

      debugPrint('Raw response from server: $response');
      debugPrint('Original Map for SavingModel: $response'); // Requested log

      final savedItem = SavingModel.fromJson(response);

      if (savedItem.id.isEmpty) {
        throw Exception('서버 응답 오류: ID 유실 (Server returned item with empty ID)');
      }

      debugPrint('Parsed item ID: ${savedItem.id}');

      // Immediately update state with the confirmed item
      final previousList = state.valueOrNull ?? [];
      state = AsyncValue.data([savedItem, ...previousList]);

      // [Step 1] 저축 성공 후 퀘스트 판정 연동
      final double amountDouble = parsedAmount.toDouble();
      final wishlistNotifier = ref.read(wishlistProvider.notifier);
      final wishlistState = ref.read(wishlistProvider);
      final activeItem = wishlistState.activeItem;

      if (activeItem != null) {
        if (activeItem.isBroken) {
          // 깨진 상태라면 퀘스트 진행도 업데이트
          await wishlistNotifier.processQuestSaving(
            activeItem.id!,
            amountDouble,
          );
        } else {
          // 정상 상태라면 기존 로직대로 진행량 업데이트
          await wishlistNotifier.updateSavedAmount(amountDouble);
        }
      }
    } catch (e) {
      debugPrint('Error in addSaving: $e');

      // [PGRST204 Fix] Missing column 'note' in schema cache
      if (e.toString().contains('PGRST204')) {
        debugPrint(
          'Retrying without explicit columns due to schema cache error...',
        );
        try {
          // Remove potential new columns preventing insert
          // [CRITICAL FIX] If 'note' column is missing, strip it and retry
          final safeJson = newItem.toJson();
          safeJson.remove('note'); // Strip note to avoid PGRST204

          final response = await ref
              .read(supabaseProvider)
              .from('savings')
              .insert({...safeJson, 'user_id': user.id})
              .select(
                'id, category, amount, created_at, wishlist_ids',
              ) // Explicitly exclude 'note'
              .single();

          if (response['id'] == null) throw Exception('Retry failed: ID null');

          final savedItem = SavingModel.fromJson(response);

          // Retry success logic
          final previousList = state.valueOrNull ?? [];
          state = AsyncValue.data([savedItem, ...previousList]);

          // [Step 1] Retry Quest Logic Link
          final double amountDouble = parsedAmount.toDouble();
          final wishlistNotifier = ref.read(wishlistProvider.notifier);
          final wishlistState = ref.read(wishlistProvider);
          final activeItem = wishlistState.activeItem;

          if (activeItem != null) {
            if (activeItem.isBroken) {
              await wishlistNotifier.processQuestSaving(
                activeItem.id!,
                amountDouble,
              );
            } else {
              await wishlistNotifier.updateSavedAmount(amountDouble);
            }
          }
          return; // Success on retry
        } catch (retryError) {
          debugPrint('Retry failed: $retryError');
          throw Exception('Failed to add saving record (Retry): $retryError');
        }
      }
      throw Exception('Failed to add saving record: $e');
    }
  }

  Future<void> deleteSaving(String id) async {
    final authNotifier = ref.read(authProvider.notifier);
    final user = ref.read(authProvider).asData?.value;

    if (authNotifier.isGuest || user == null) {
      _guestSavings.removeWhere((item) => item.id == id);

      // [Persistence] Save to SharedPrefs
      try {
        final prefs = await SharedPreferences.getInstance();
        final String encodedData = jsonEncode(
          _guestSavings.map((e) => e.toJson()).toList(),
        );
        await prefs.setString('guest_savings', encodedData);
      } catch (e) {
        debugPrint('Failed to save guest savings after delete: $e');
      }

      state = AsyncValue.data([..._guestSavings]);
      return;
    }

    try {
      final response = await ref
          .read(supabaseProvider)
          .from('savings')
          .delete()
          .eq('id', id)
          .select();

      debugPrint('Saving delete result: $response');

      // Refresh the list only if successful
      ref.invalidateSelf();
    } catch (e) {
      debugPrint('Error in deleteSaving: $e');
      throw Exception('Failed to delete saving record: $e');
    }
  }

  Future<void> deleteAllSavings() async {
    final authNotifier = ref.read(authProvider.notifier);
    final user = ref.read(authProvider).asData?.value;

    if (authNotifier.isGuest || user == null) {
      _guestSavings.clear();

      // [Persistence] Clear SharedPrefs
      try {
        final prefs = await SharedPreferences.getInstance();
        await prefs.remove('guest_savings');
      } catch (e) {
        debugPrint('Failed to clear guest savings: $e');
      }

      state = const AsyncValue.data([]);
      return;
    }

    try {
      await ref
          .read(supabaseProvider)
          .from('savings')
          .delete()
          .eq('user_id', user.id);

      state = const AsyncValue.data([]);
    } catch (e) {
      debugPrint('Error in deleteAllSavings: $e');
      throw Exception('Failed to delete all savings: $e');
    }
  }
}

final savingProvider = savingNotifierProvider;

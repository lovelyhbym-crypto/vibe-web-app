import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../core/network/supabase_client.dart';
import 'package:vive_app/features/auth/providers/auth_provider.dart';
import '../domain/saving_model.dart';

part 'saving_provider.g.dart';

@Riverpod(keepAlive: true)
class SavingNotifier extends _$SavingNotifier {
  // Local storage for guest users
  final List<SavingModel> _guestSavings = [];

  @override
  FutureOr<List<SavingModel>> build() async {
    final authNotifier = ref.watch(authProvider.notifier);
    final user = ref.watch(authProvider).asData?.value;

    if (authNotifier.isGuest || user == null) {
      return _guestSavings;
    }

    // Fetch from Supabase for logged-in users
    final response = await ref
        .read(supabaseProvider)
        .from('savings')
        .select()
        .order('created_at', ascending: false);

    // Filter out items with null IDs
    final safeResponse = response.where((e) => e['id'] != null).toList();

    if (safeResponse.length < response.length) {
      print(
        'Filtered out ${response.length - safeResponse.length} savings with null IDs',
      );
    }

    return safeResponse.map((e) => SavingModel.fromJson(e)).toList();
  }

  Future<void> addSaving({
    required String category,
    required dynamic amount,
    required DateTime createdAt,
  }) async {
    final authNotifier = ref.read(authProvider.notifier);
    final user = ref.read(authProvider).asData?.value;

    // Safe parsing logic
    final int parsedAmount = int.tryParse(amount?.toString() ?? '0') ?? 0;

    if (authNotifier.isGuest || user == null) {
      // Generate a temporary ID for guest
      final newItem = SavingModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        category: category,
        amount: parsedAmount,
        createdAt: createdAt,
      );
      _guestSavings.insert(0, newItem);
      state = AsyncValue.data([..._guestSavings]);
      return;
    }

    try {
      final newItem = SavingModel(
        id: '', // Empty ID as it will be generated by Supabase (toJson omits it)
        category: category,
        amount: parsedAmount,
        createdAt: createdAt,
      );

      final response = await ref
          .read(supabaseProvider)
          .from('savings')
          .insert({...newItem.toJson(), 'user_id': user.id})
          .select()
          .single();

      print('Raw response from server: $response');
      print('Original Map for SavingModel: $response'); // Requested log

      final savedItem = SavingModel.fromJson(response);

      if (savedItem.id.isEmpty) {
        throw Exception('서버 응답 오류: ID 유실 (Server returned item with empty ID)');
      }

      print('Parsed item ID: ${savedItem.id}');

      // Immediately update state with the confirmed item
      final previousList = state.valueOrNull ?? [];
      state = AsyncValue.data([savedItem, ...previousList]);
    } catch (e) {
      print('Error in addSaving: $e');
      throw Exception('Failed to add saving record: $e');
    }
  }

  Future<void> deleteSaving(String id) async {
    final authNotifier = ref.read(authProvider.notifier);
    final user = ref.read(authProvider).asData?.value;

    if (authNotifier.isGuest || user == null) {
      _guestSavings.removeWhere((item) => item.id == id);
      state = AsyncValue.data([..._guestSavings]);
      return;
    }

    try {
      final response = await ref
          .read(supabaseProvider)
          .from('savings')
          .delete()
          .eq('id', id)
          .select();

      print('Saving delete result: $response');

      // Refresh the list only if successful
      ref.invalidateSelf();
    } catch (e) {
      print('Error in deleteSaving: $e');
      throw Exception('Failed to delete saving record: $e');
    }
  }
}

final savingProvider = savingNotifierProvider;
